function [confidence]=BS_CI(estimates, param_bs);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Equi-tailed Confidence Interval (CI) Calculation for an estimate 
%         using non-parametric Bootstrap (BS) statistics
%%
% function [confidence]=BS_CI(estimates, param_bs, alpha);
%% 
% INPUT VARIABLES
%   estimates     - Structure containing estimates and BS distributions
%          estimates.t     :   Estimate
%          estimates.stdt  :   BS std estimate of std(t)
%          estimates.T     :   array of BS resample estimates t* of t                   [only for ci_method 4]
%          estimates.stdT  :   array of BS std estimate of std(t*)                      [only for ci_method 4]
%          estimates.TT    :   matrix of BS re-resample estimates t** of t*             [only for ci_method 5 and 6]
%   param_bs   - Structure containing BS relevant parameters:
%          param_bs.n_resamp_1    : # primary BS resamples (for empirical pdf)     [default: 999]
%          param_bs.n_resamp_2    : # secondary BS resamples (var and adjusted)    [default: 50]
%          param_bs.block_size : block length for moving blocks BS (1 for ordinary BS) [default: 1]
%          param_bs.ci_method      : array with numbers from 1:8 determining which Confidence interval
%                                to calculate (e.g. [3] or [1 2 5] - multiple choices possible)
%                                                                               [default: 1:6]
%                                  1 - Normal approximation CI      [recommended n_resamp_2 = 50]
%                                  2 - Basic BS CI                  [recommended n_resamp_2 = 999]
%                                  3 - Percentile BS CI             [recommended n_resamp_2 = 999]
%                                  4 - Studentised BS CI            [recommended n_resamp_2 = 999]
%                                  5 - Adjusted Basic BS CI         [recommended n_resamp_2 = 250]
%                                  6 - Adjusted Percentile BS CI    [recommended n_resamp_2 = 250]
%  alpha                   : (1 - alpha) confidence limits                      [default: 0]
%%
% OUTPUT VARIABLES
%   confidence    - Structure containing CI (and relevant information)
%          confidence{i}   - substructure for each CI (i=1:6) with elements:
%          confidence{i}.name  : Name of CI (e.g. 'normal' for i=1)
%          confidence{i}.lo    : Lower CI limit
%          confidence{i}.hi    : Upper CI limit
%          confidence{i}.length: Length of CI
%          confidence{i}.shape : Shape of CI [ shape=(.hi-t)/(t-.lo) ]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   USAGE EXAMPLE :
%   Batch mode calculation of Percentile, Studentised, BCa 95% CI for estimates
%       param_bs  = struct('n_resamp_1', 999, 'n_resamp_2', 50, 'block_size', 1, 'ci_method', [3 4 5]);
%       alpha=0.05;
%   % NOTE: corresponding BS estimates must exist, e.g. generated by function BSsample
%       [confidence] = BS_CI(estimates, param_bs, alpha);
%
% Herwig Wendt, Lyon, 2006 - 2008
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
%%%%%%%%%%%%%%%%%%%%%%%%%
% CHECK FOR CORRECT USE
%%%%%%%%%%%%%%%%%%%%%%%%%
% Check use of function
if nargout>1
    error('TOO MANY OUTPUT PARAMETERS.');
end

alpha = param_bs.alpha;

% Check input arguments: param_bs, alpha
InputError1='param_bs must be a structure with elements: \n   param_bs.n_resamp_1 \n   param_bs.n_resamp_2 \n   param_bs.block_size \n   param_bs.ci_method \n   param_bs.verb (optional) \n ';
try  NB1=isreal(param_bs.n_resamp_1);      if ~NB1; param_bs.n_resamp_1=999;  end; catch error(InputError1, NB1); end
try  NB2=isreal(param_bs.n_resamp_2);      if ~NB2; param_bs.n_resamp_2=50;   end; catch error(InputError1, NB2); end
try  NB3=isreal(param_bs.block_size);   if ~NB3; param_bs.blocklength=1; end; catch error(InputError1, NB3); end
try  NB4=isreal(param_bs.ci_method);        if ~NB4; param_bs.ci_method=[1:6];  end; catch error(InputError1, NB4); end
try  NB5=isreal(alpha);                 if ~NB5; alpha=0.05;            end; catch fprintf('Alpha not valid.\nReset to default 0.05.\n'); end

% Check which method is used
ci_method=param_bs.ci_method; CIdisp=[];
if isempty(ci_method); return; end;
if find(ci_method==1);                 NOR=1; CIdisp=[CIdisp 1];       else NOR=0; end
if find(ci_method==2);                 BAS=1; CIdisp=[CIdisp 2];       else BAS=0; end
if find(ci_method==3);                 PER=1; CIdisp=[CIdisp 3];       else PER=0; end
if find(ci_method==4);                 STU=1; CIdisp=[CIdisp 4];       else STU=0; end
if find(ci_method==5)|find(ci_method==6); ADJ=1;                          else ADJ=0; end
if find(ci_method==5);                 BASADJ=1; CIdisp=[CIdisp 5];    else BASADJ=0; end
if find(ci_method==6);                 PERADJ=1; CIdisp=[CIdisp 6];    else PERADJ=0; end

% Check input arguments: estimates
InputError2='estimates must be a structure with elements:\n   estimates.t \n   estimates.stdT\n   estimates.T\n   estimates.stdT (STU; adjusted)\n\n';
% t
try  NB=isreal(estimates.t); catch error(InputError2, NB); end
if ~NB|length(estimates.t)~=1; error('Estimate estimates.t must be a scalar'); end
t=estimates.t;
% T
try  NB=isreal(estimates.T); catch error(InputError2, NB); end
[a,b]=size(estimates.T);
if ~NB|max(a,b)~=param_bs.n_resamp_1|min(a,b)~=1; error('Estimate estimates.T must be a vector of size param_bs.n_resamp_1'); end
T=estimates.T;
% stdt
if STU|NOR
    try  NB=isreal(estimates.stdt); catch error(InputError2, NB); end
    if ~NB|length(estimates.stdt)~=1; error('Estimate estimates.stdt must be a scalar'); end
    try  NB=isreal(estimates.stdt); catch error(InputError2, NB);  end
    stdt=estimates.stdt;
end
% stdT
if STU    
    try  NB=isreal(estimates.stdT); catch error('Estimate estimates.stdT must be a vector of size param_bs.n_resamp_1'); end
    [a,b]=size(estimates.stdT);
    if ~NB|max(a,b)~=param_bs.n_resamp_1|min(a,b)~=1; error('Estimate estimates.stdT must be a vector of size param_bs.n_resamp_1'); end
    stdT=estimates.stdT;
end
% TT
if BASADJ|PERADJ
    try  NB=isreal(estimates.TT); catch error('estimates.TT must be a matrix of size param_bs.n_resamp_1 x param_bs.n_resamp_2.'); end
    [a,b]=size(estimates.TT);
    if ~NB|a~=param_bs.n_resamp_1|b~=param_bs.n_resamp_2; error('estimates.TT must be a matrix of size param_bs.n_resamp_1 x param_bs.n_resamp_2.'); end
    TT=estimates.TT;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SETUP 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bootstrap parameters
w=0.4;          % window width (data length fraction) for Variance Function smoothing (Variance stabilising transformation CI)
B1=param_bs.n_resamp_1;        % number of primary bootstrap resamples
B2=param_bs.n_resamp_2;        % number of bootstrap resamples for variance estimates (used for Normal, Studentised, Variance Stabilising Transformation)
block_size=param_bs.block_size;  % Block length for moving blocks resampling
IDloalpha=floor((B1+1)*alpha/2);      % lower Bootstrap distribution quantile CI equi-tailed
IDupalpha=ceil((B1+1)*(1-alpha/2));   % upper Bootstrap distribution quantile CI equi-tailed
IDupalpha=min(IDupalpha, B1);
IDloalpha=max(IDloalpha, 1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CALCULATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%
% Normal Approximation with Bootstrap variance estimate
%%%%%%%%%%%%%%%%%%%%%%%%%%
if NOR    
    %%%%%%%%%%%%%%%%%%%%%%%%%%
    % CI    
    normLO=t-sqrt(2)*erfinv(2*(1-alpha/2)-1)*stdt;
    normUP=t+sqrt(2)*erfinv(2*(1-alpha/2)-1)*stdt;
    confidence{1}=struct('name','NOR    ','lo', normLO,'hi', normUP);
else
    confidence{1}=struct('name','Normal not calculated','lo', NaN,'hi', NaN);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%
% Basic CI
%%%%%%%%%%%%%%%%%%%%%%%%%%
if BAS
    Tsort=sort(T);
    basicLO=2*t-Tsort(IDupalpha) ;
    basicUP=2*t-Tsort(IDloalpha) ;
    confidence{2}=struct('name','BAS    ','lo', basicLO,'hi',basicUP);
else
    confidence{2}=struct('name','Basic not calculated','lo', NaN,'hi', NaN);  
end
%%%%%%%%%%%%%%%%%%%%%%%%%%
% Adjusted Basic CI
%%%%%%%%%%%%%%%%%%%%%%%%%%
if BASADJ      % Adjusted Basic CI
    Tsort=sort(T);    
    % NEW CALCULATION: FASTER
    pb= (sum(TT<=2*repmat(T',1,B2)-t,2)) / (B2); pb=pb';    %% DAVISON
    pb=sort(pb);
    padjlo=pb(IDloalpha);  % for upper limit 
    padjup=pb(IDupalpha);  % for lower limit
    IDloalphaadj=max(1,min(floor((B1+1)*padjlo),B1));  % lower limit index 
    IDupalphaadj=max(1,min(ceil((B1+1)*padjup),B1));  % upper limit index 
    basicLOadj=2*t-Tsort(IDupalphaadj);    %lower limit 
    basicUPadj=2*t-Tsort(IDloalphaadj);     %upper limit     
    confidence{5}=struct('name','BAS Adj','lo', basicLOadj,'hi',basicUPadj);
else
    confidence{5}=struct('name','Basic Adj not calculated','lo', NaN,'hi', NaN);  
end

%%%%%%%%%%%%%%%%%%%%%%%%%%
% Percentile CI
%%%%%%%%%%%%%%%%%%%%%%%%%%
if PER
    % CI 
    Tsort=sort(T);  
    percentLO=Tsort(IDloalpha) ;
    percentUP=Tsort(IDupalpha) ;
    confidence{3}=struct('name','PER    ','lo', percentLO,'hi',percentUP);
else
    confidence{3}=struct('name','Percent not calculated','lo', NaN,'hi', NaN);    
end
%%%%%%%%%%%%%%%%%%%%%%%%%%
% Adjusted Percentile CI
%%%%%%%%%%%%%%%%%%%%%%%%%%
if PERADJ      % Adjusted Percentile CI
    Tsort=sort(T);      
    % NEW CALCULATION: FASTER
    pb= (sum(TT<=t,2)) / (B2); pb=pb';    %% DAVISON
    pb=sort(pb);
    %% MY VERSION
    padjlo=pb(IDloalpha);  % for lower limit 
    padjup=pb(IDupalpha);  % for upper limit
    IDloalphaadj=max(1,min(floor((B1+1)*padjlo),B1));  % upper limit index 
    IDupalphaadj=max(1,min(ceil((B1+1)*padjup),B1));  % lower limit index 
    perLOadj=Tsort(IDloalphaadj);    %lower limit 
    perUPadj=Tsort(IDupalphaadj);     %upper limit     
    confidence{6}=struct('name','PER Adj','lo', perLOadj,'hi',perUPadj);
else
    confidence{6}=struct('name','Percentile Adj not calculated','lo', NaN,'hi', NaN);  
end
%%%%%%%%%%%%%%%%%%%%%%%%%%
% Studentised CI
%%%%%%%%%%%%%%%%%%%%%%%%%%
if STU    
    Z=(T-t)./stdT;
    Tstud=Z.*stdt+t;
    %%%%%%%%%%%%%%%%%%%%%%%%%%
    % CI
    Zsort=sort(Z);
    studLO=t-stdt*Zsort(IDupalpha) ;
    studUP=t-stdt*Zsort(IDloalpha) ;
    confidence{4}=struct('name','STU    ','lo', studLO,'hi',studUP);
else
    confidence{4}=struct('name','Student not calculated','lo', NaN,'hi', NaN);    
end