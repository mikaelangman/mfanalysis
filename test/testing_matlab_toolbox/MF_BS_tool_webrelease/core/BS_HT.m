function [significance]=BS_HT(estimates, param_bs, param_test);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Bootstrap (BS) Hypothesis Tests for a single parameter T using
%     direct Bootstrap Tests and Inversion of Confidence Limits
%%
% [significance]=BS_HT(estimates, param_bs, param_test, alpha);
%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CAUTION:
%  - ci_method 3 (Percentile) and 6 (Adjusted Percentile) for Hypothesis null_type 3 are identical to 2 and 5 
%      since inversion percentile limits not possible in this case
%  - ci_method 5 and 6 (Adjusted) do NOT correspond exactly with the confidence limits 5 and 6
%      since they are not equivalent to inversion of the corresponding confidence limits
% NOT YET IMPLEMENTED:
%  - Advanced Methods for Studentised Power function estimate
%  - Test by Confidence Limit inversion for adjusted methods
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INPUT VARIABLES
%   estimates     - Structure containing estimates and BS distributions (e.g. generated by BSsample.m)
%          estimates.t     :   Estimate
%          estimates.stdt  :   BS std estimate of std(t)
%          estimates.T     :   array of BS resample estimates t* of t                   [only for ci_method 4]
%          estimates.stdT  :   array of BS std estimate of std(t*)                      [only for ci_method 4]
%          estimates.TT    :   matrix of BS re-resample estimates t** of t*             [only for ci_method 5 and 6]
%   param_bs   - Structure containing BS relevant parameters:
%          param_bs.n_resamp_1    : # primary BS resamples (for empirical pdf)     [default: 999]
%          param_bs.n_resamp_2    : # secondary BS resamples (var and adjusted)    [default: 50]
%          param_bs.block_size : block length for moving blocks BS (1 for ordinary BS) [default: 1]
%          param_bs.ci_method      : array with numbers from 1:8 determining which Null Hypothesis estimate
%                                to use (e.g. [3] or [1 2 5] - multiple choices possible)
%                                                                               [default: 1:6]
%                                  1 - Normal approximation         [recommended n_resamp_2 = 50]
%                                  2 - Basic BS                     [recommended n_resamp_2 = 999]
%                                  3 - Percentile BS                [recommended n_resamp_2 = 999]
%                                  4 - Studentised BS               [recommended n_resamp_2 = 999]
%                                  5 - Adjusted Basic BS            [recommended n_resamp_2 = 250]
%                                  6 - Adjusted Percentile BS       [recommended n_resamp_2 = 250]
%   param_test   - structure containing Hypothesis Test relevant parameters:
%          param_test.null_type      : array with numbers from 1:4 determining which Test to use
%                                                                               [default: 1:4]
%                                  1 - testing the parameter t for t=tnull against t>null_param     
%                                  2 - testing the parameter t for t=tnull against t<null_param  
%                                  3 - testing the parameter t for t=tnull : |t-null_param|=0 
%                                  4 - testing the parameter t for t=tnull :  t-null_param =0 (inversion of equi-tailed confidence limits)
%          param_test.null_param        : Null hypothesis value
%   alpha                  : (1 - alpha) Significance level                     [default: 0.05]
%%
% OUTPUT VARIABLES
%   significance{i}{j} - Structure containing Hypothesis Test results:
%          significance{i}{j}.name      - String: null distribution estimate method and Hypothesis
%          significance{i}{j}.reject    - Result of Test (0 or 1)
%          significance{i}{j}.plevel    - p-level of estimate
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   USAGE EXAMPLES :
%%   Batch mode calculation of Percentile, Studentised 95% Test of H0: |t-null_param|=0 with null_param=3.5
%           param_bs   = struct('n_resamp_1', 999, 'n_resamp_2', 50, 'block_size', 1, 'ci_method', [3 4]);
%           param_test = struct('null_type', [3], 'null_param', 3.5);
%           alpha=0.05;
%       % NOTE: corresponding BS estimates must exist, e.g. generated by function BSsample.m
%           [significance]=BS_HT(estimates, param_bs, param_test, alpha);
%
% Herwig Wendt, Lyon, 2006 - 2008
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%
%
% I - CHECK FOR CORRECT USE, SET DEFAULT VALUES
%
%%%%%%%%%%%%%%%%%%%%%%%%%
% Check use of function
LEVELFUN=0;
if nargin==3; 
elseif (nargin<3)|(nargin>4)
    error('WRONG NUMBER OF INPUT PARAMETERS.');
end

alpha = param_bs.alpha;

% Check input arguments: param_bs, param_test, alpha
InputError1='param_bs must be a structure with elements:\n   param_bs.n_resamp_1 \n   param_bs.n_resamp_2\n   param_bs.block_size\n   param_bs.ci_method\n';
InputError1a='param_test must be a structure with elements:\n   param_test.null_type \n   param_test.null_param\n';
try  NB1=isreal(param_bs.n_resamp_1);      if ~NB1; param_bs.n_resamp_1=999;  end; catch error(InputError1, NB1); end
try  NB2=isreal(param_bs.n_resamp_2);      if ~NB2; param_bs.n_resamp_2=50;   end; catch error(InputError1, NB2); end
try  NB3=isreal(param_bs.block_size);   if ~NB3; param_bs.blocklength=1; end; catch error(InputError1, NB3); end
try  NB4=isreal(param_bs.ci_method);        if ~NB4; param_bs.ci_method=[1:6];  end; catch error(InputError1, NB4); end
try  NB6=isreal(param_test.null_type);        if ~NB6; param_test.null_type=[1:4];  end; catch error(InputError1a,NB6); end
try  NB7=isreal(param_test.null_param);                                               catch error(InputError1a,NB7); end
    if ~NB7|length(param_test.null_param)~=1; error('Null hypothesis param_test.null_param must be a scalar.'); end
    tnull = param_test.null_param;
try  NB5=isreal(alpha);                 if ~NB5; alpha=0.05;            end; catch fprintf('Alpha not valid.\nReset to default 0.05.\n'); end
% Check which methods are demanded
ci_method=param_bs.ci_method; Hdisp=[];
if isempty(ci_method); return; end;
if find(ci_method==1);                 NOR=1;     Hdisp=[Hdisp 1];   else NOR=0; end
if find(ci_method==2)|find(ci_method==3); BAS=1;     Hdisp=[Hdisp 2];   else BAS=0; end
if find(ci_method==3);                 PER=1;     Hdisp=[Hdisp 3];   else PER=0; end
if find(ci_method==4);                 STU=1;     Hdisp=[Hdisp 4];   else STU=0; end
if find(ci_method==5);                 BASADJ=1;  Hdisp=[Hdisp 5];   else BASADJ=0; end
if find(ci_method==6);                 PERADJ=1;  Hdisp=[Hdisp 6];   else PERADJ=0; end
% Check which Test Statistics are demanded
null_type = param_test.null_type; Htype=[];
if find(null_type==1); LEQ=1; Htype=[Htype 1]; else LEQ=0; end
if find(null_type==2); GEQ=1; Htype=[Htype 2]; else GEQ=0; end
if find(null_type==3); EQS=1; Htype=[Htype 3]; else EQS=0; end
if find(null_type==4); EQA=1; Htype=[Htype 4]; else EQA=0; end

% Check input arguments: estimates
InputError2='estimates must be a structure with elements:\n   estimates.t \n   estimates.stdT\n   estimates.T\n   estimates.stdT (STU; ADJ)\n   estimates.TT (ADJ)\n';
% t, T
try  NB=isreal(estimates.t); catch error(InputError2, NB); end
if ~NB|length(estimates.t)~=1; error('Estimate estimates.t must be a scalar'); end
t=estimates.t;
try  NB=isreal(estimates.T); catch error(InputError2, NB); end
[a,b]=size(estimates.T);
if ~NB|max(a,b)~=param_bs.n_resamp_1|min(a,b)~=1; error('Estimate estimates.T must be a vector of size param_bs.n_resamp_1'); end
T=estimates.T;
% stdt
if STU|NOR
    try  NB=isreal(estimates.stdt); catch error(InputError2), NB; end
    if ~NB|length(estimates.stdt)~=1; error('Estimate estimates.stdt must be a scalar'); end
    try  NB=isreal(estimates.stdt); catch error(InputError2, NB); end
    stdt=estimates.stdt;
end
% stdT
if STU    
    try  NB=isreal(estimates.stdT); catch error(InputError2, NB); end
    [a,b]=size(estimates.stdT);
    if ~NB|max(a,b)~=param_bs.n_resamp_1|min(a,b)~=1; error('Estimate estimates.stdT must be a vector of size param_bs.n_resamp_1'); end
    stdT=estimates.stdT;
end
% TT
if PERADJ|BASADJ
    try  NB=isreal(estimates.TT); catch error(InputError2, NB); end
    [a,b]=size(estimates.TT);
    if ~NB|a~=param_bs.n_resamp_1|b~=param_bs.n_resamp_2; error('estimates.TT must be a matrix of size param_bs.n_resamp_1 x param_bs.n_resamp_2.'); end
    TT=estimates.TT;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% II - SETUP AND INITIALISATION
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bootstrap parameters
w=0.4;          % window width (data length fraction) for Variance Function smoothing (Variance stabilising transformation Method)
B1=param_bs.n_resamp_1;        % # of primary bootstrap resamples
B2=param_bs.n_resamp_2;        % # of bootstrap resamples for variance estimates and adjusted methods (used for Normal, Studentised, Variance Stabilising Transformation, Adjusted)
IDloalpha=floor((B1+1)*alpha/2);    IDloalpha=max(IDloalpha, 1);    % lower Bootstrap distribution quantile
IDupalpha=ceil((B1+1)*(1-alpha/2)); IDupalpha=min(IDupalpha, B1);   % upper Bootstrap distribution quantile
sIDloalpha=floor((B1+1)*alpha);     sIDloalpha=max(sIDloalpha, 1);  % lower Bootstrap distribution quantile single sided
sIDupalpha=ceil((B1+1)*(1-alpha));  sIDupalpha=min(sIDupalpha, B1); % upper Bootstrap distribution quantile single sided
% Initialise all structures
for ii=1:6
    for jj=1:4
        significance{ii}{jj}=struct([]);                % Structure containing results of tests
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% III - CALCULATION OF TESTS
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%
% ci_method 1: Normal Approximation with Bootstrap variance estimate
%%%%%%%%%%%%%%%%%%%%%%%%%%
if NOR    
    null_param=linspace(-3*stdt+tnull, 3*stdt+tnull, 2*B1);       % parameter space for p-level function estimation
    if LEQ  %% Hnull: t=t0 against t>tnull      
        norpval=1-normcdf((t-tnull),0,stdt) ;               % p value
        if norpval<=alpha; norTest=1; else norTest=0; end   % Test
        significance{1}{1}=struct('name', 'Normal Alt: t>tnull', 'reject', norTest, 'plevel', norpval);
    end
    if GEQ  %% Hnull: t=t0 against t<tnull      
        norpval=normcdf((t-tnull),0,stdt) ;                 % p value
        if norpval<=alpha; norTest=1; else norTest=0; end   % Test
        significance{1}{2}=struct('name', 'Normal Alt: t<tnull', 'reject', norTest, 'plevel', norpval);
    end
    if EQS  % Hnull: t=tnull
        norpval=1-absNstd((abs(t-tnull))/stdt);             % p value
        if norpval<=alpha; norTest=1; else norTest=0; end   % Test
        significance{1}{3}=struct('name', 'Normal |t-tnull|=0', 'reject', norTest, 'plevel', norpval);
    end   
    if EQA  % Hnull: t=tnull
        norpval=2*(1-normcdf((abs(t-tnull)),0,stdt));       % p value; Factor 2: two tails   
        if norpval<=alpha; norTest=1; else norTest=0; end   % Test
        significance{1}{4}=struct('name', 'Normal t-tnull=0', 'reject', norTest, 'plevel', norpval);
    end   
end
%%%%%%%%%%%%%%%%%%%%%%%%%%
% ci_method 2: Basic Significance
%%%%%%%%%%%%%%%%%%%%%%%%%%
if BAS|BASADJ
    if LEQ  %% Hnull: t=t0 against t>tnull
        s=t-tnull;      % Test statistic: S=T-tnull; large values are evidence against Hnull
        S=sort(T)-t;    % Test statistic Null distribution: S*=T*-t
        if s>=S(sIDupalpha); basTest=1; else basTest=0; end     % Test 
        baspval=(1+length(find(S>=s)))/(B1+1);                  % pvalue
        significance{2}{1}=struct('name', 'Basic Alt: t>tnull', 'reject', basTest, 'plevel', baspval);
    end
    if GEQ  %% Hnull: t=t0 against t<tnull
        s=tnull-t;      % Test statistic: S=tnull-T; large values are evidence against Hnull
        S=t-sort(T);    % Test statistic Null distribution: S*=t-T*
        if s>=S(sIDloalpha); basTest=1; else basTest=0; end     % Test 
        baspval=(1+length(find(S>=s)))/(B1+1);                  % pvalue
        significance{2}{2}=struct('name', 'Basic Alt: t<tnull', 'reject', basTest, 'plevel', baspval);
    end
    if EQS  %% Hnull: t=tnull (symmetric)
        s=abs(t-tnull);         % Test statistic: U=|T-tnull|; large values are evidence against Hnull
        S=sort(abs(T-t));       % Test statistic Null distribution: U*=|T*-t|        
        if s>=S(sIDupalpha); basTest=1; else basTest=0; end     % Test         
        baspval=(1+length(find(S>=s)))/(B1+1);                  % pvalue
        significance{2}{3}=struct('name', 'Basic |t-tnull|=0', 'reject', basTest, 'plevel', baspval);
    end
    if EQA  %% Hnull: t=tnull, non-symmetric by inversion of confidence interval
        s=t-tnull;          % Test statistic: U=T-tnull; large values are evidence against Hnull
        S=sort(T)-t;        % Test statistic Null distribution: U*=T*-t       
        if (s>=S(IDupalpha))|(s<=S(IDloalpha)); basTest=1; else basTest=0; end  % Test 
        p1=(1+length(find(S>=s)))/(B1+1);                       % "level p" on the left
        p2=(1+length(find(S<=s)))/(B1+1);                       % "level p" on the right
        baspval=2*min(p1,p2);                                                   % p-value
        significance{2}{4}=struct('name', 'Basic t-tnull=0', 'reject', basTest, 'plevel', baspval);
    end    
end


%%%%%%%%%%%%%%%%%%%%%%%%%%
% ci_method 7: Adjusted Basic p-Value - Double Bootstrap
%%%%%%%%%%%%%%%%%%%%%%%%%%
if BASADJ
    S1=(T-t);        % Bootstrap null distributions F0*
    S2=-(T-t);
    S3=(abs(T-t)); 
    % NEW CALCULATION: FASTER
    if LEQ|EQA; SS1=sort(TT-repmat(T',1,B2),2); end;
    if GEQ|EQA;     SS2=sort(-TT+repmat(T',1,B2),2); end; 
    if EQS;     SS3=(abs(TT-repmat(T',1,B2))); end;
    if LEQ; pbleq= ( 1 + sum(SS1>=repmat(S1',1,B2), 2)) / (B2+1); pbleq=pbleq'; end
    if GEQ; pbgeq= ( 1 + sum(SS2>=repmat(S2',1,B2), 2)) / (B2+1);  pbgeq=pbgeq'; end
    if EQS; pbeqs= ( 1 + sum(SS3<=repmat(S3',1,B2), 2)) / (B2+1);  pbeqs=pbeqs'; end
    if EQA; 
        p1 = 2*(1+sum(SS1>=repmat(S1',1,B2), 2))/(B2+1);
        p2 = 2*(1+sum(SS2>=repmat(S2',1,B2), 2))/(B2+1);
        pbeqa=min(p1,p2)';
    end
    if LEQ  %% Hnull: t=t0 against t>tnull
        adjpval=( 1 + length(find(pbleq<=significance{2}{1}.plevel))) / (B1+1) ;
        if adjpval<=alpha; adjTest=1; else adjTest=0; end
        significance{5}{1}=struct('name', 'Adj Bas Alt: t>tnull', 'reject', adjTest, 'plevel', adjpval);
    end
    if GEQ  %% Hnull: t=t0 against t<tnull
        adjpval=( 1 + length(find(pbgeq<=significance{2}{2}.plevel))) / (B1+1) ;
        if adjpval<=alpha; adjTest=1; else adjTest=0; end
        significance{5}{2}=struct('name', 'Adj Bas Alt: t<tnull', 'reject', adjTest, 'plevel', adjpval);
    end
    if EQS  %% Hnull: t=tnull (symmetric)
        adjpval=( 1 + length(find(pbeqs<=significance{2}{3}.plevel))) / (B1+1) ;
        if adjpval<=alpha; adjTest=1; else adjTest=0; end
        significance{5}{3}=struct('name', 'Adj Bas |t-tnull|=0', 'reject', adjTest, 'plevel', adjpval);
    end
    if EQA  %% Hnull: t=tnull, non-symmetric by inversion of confidence interval
        adjpval=( 1 + length(find(pbeqa<=significance{2}{4}.plevel))) / (B1+1) ;
        if adjpval<=alpha; adjTest=1; else adjTest=0; end
        significance{5}{4}=struct('name', 'Adj Bas t-tnull=0', 'reject', adjTest, 'plevel', adjpval);
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%
% ci_method 3: Percentile Significance
%%%%%%%%%%%%%%%%%%%%%%%%%%
if PER|PERADJ
    if LEQ %% Hnull: t=t0 against t>tnull
        s=t-tnull;  % Test statistic: S=T-tnull; large values are evidence against Hnull
        S=sort(T)-t;  % Test statistic Null distribution: S*=T*-t
        if s>=-S(sIDloalpha); perTest=1; else perTest=0; end   % Test 
        perpval=(1+length(find(-S>=s)))/(B1+1);  % pvalue
        significance{3}{1}=struct('name', 'Percent Alt: t>tnull', 'reject', perTest, 'plevel', perpval);        
    end
    if GEQ %% Hnull: t=t0 against t<tnull
        s=tnull-t;  % Test statistic: S=tnull-T; large values are evidence against Hnull
        S=t-sort(T);  % Test statistic Null distribution: S*=t-T*
        if s>=-S(sIDupalpha); perTest=1; else perTest=0; end   % Test 
        perpval=(1+length(find(-S>=s)))/(B1+1);  % pvalue
        significance{3}{2}=struct('name', 'Percent Alt: t<tnull', 'reject', perTest, 'plevel', perpval);
    end
    %%%%%%%
    % NOT POSSIBLE FROM PERCENTILE CI INVERSION --> USE BASIC BS TEST
    %%%%%%%
    if EQS %% Hnull: t=tnull (symmetric)
        s=abs(t-tnull);     % Test statistic: S=|T-tnull|; large values are evidence against Hnull
        S=sort(abs(T-t)); % Test statistic Null distribution: S*=|T*-t|        
        if s>=S(sIDupalpha); perTest=1; else perTest=0; end   % Test         
        perpval=(1+length(find(S>=s)))/(B1+1);  % pvalue
        significance{3}{3}=struct('name', 'Percent |t-tnull|=0', 'reject', perTest, 'plevel', perpval);
    end
    if EQA %% Hnull: t=tnull, non-symmetric
        s=t-tnull;  % Test statistic: S=T-tnull; large values are evidence against Hnull
        S=sort(T)-t; % Test statistic Null distribution: S*=T*-t       
        if (s>=-S(IDloalpha))|(s<=-S(IDupalpha)); perTest=1; else perTest=0; end   % Test 
        p1=(1+length(find(-S>=s)))/(B1+1);
        p2=(1+length(find(-S<=s)))/(B1+1);
        perpval=2*min(p1,p2);  % p-value
        significance{3}{4}=struct('name', 'Percent t-tnull=0', 'reject', perTest, 'plevel', perpval);
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%
% ci_method 8: Adjusted Percentile p-Value - Double Bootstrap
%%%%%%%%%%%%%%%%%%%%%%%%%%
if PERADJ
    S1=(T-t);        % Bootstrap null distributions F0*
    S2=-(T-t);
    S3=(abs(T-t)); 
    % NEW CALCULATION: FASTER
    if LEQ|EQA; SS1=sort(TT-repmat(T',1,B2),2); end;
    if GEQ|EQA;     SS2=sort(-TT+repmat(T',1,B2),2); end; 
    if EQS;     SS3=(abs(TT-repmat(T',1,B2))); end;
    if LEQ; pbleq= ( 1 + sum(-SS1>=repmat(S1',1,B2), 2)) / (B2+1); pbleq=pbleq'; end
    if GEQ; pbgeq= ( 1 + sum(-SS2>=repmat(S2',1,B2), 2)) / (B2+1);  pbgeq=pbgeq'; end
    if EQS; pbeqs= ( 1 + sum(SS3<=repmat(S3',1,B2), 2)) / (B2+1);  pbeqs=pbeqs'; end
    if EQA; 
        p1=2*( 1 + sum(-SS1>=repmat(S1',1,B2), 2)) / (B2+1);
        p2=2*( 1 + sum(-SS2>=repmat(S2',1,B2), 2)) / (B2+1);
        pbeqa=min(p1,p2)';
    end
    if LEQ %% Hnull: t=t0 against t>tnull
        adjpval=( 1 + length(find(pbleq<=significance{3}{1}.plevel))) / (B1+1) ;
        if adjpval<=alpha; adjTest=1; else adjTest=0; end
        significance{6}{1}=struct('name', 'Adj Per Alt: t>tnull', 'reject', adjTest, 'plevel', adjpval);
    end
    if GEQ %% Hnull: t=t0 against t<tnull
        adjpval=( 1 + length(find(pbgeq<=significance{3}{2}.plevel))) / (B1+1) ;
        if adjpval<=alpha; adjTest=1; else adjTest=0; end
        significance{6}{2}=struct('name', 'Adj Per Alt: t<tnull', 'reject', adjTest, 'plevel', adjpval);
    end
    %%%%%%%
    % NOT POSSIBLE FROM PERCENTILE CI INVERSION --> USE BASIC BS TEST
    %%%%%%%
    if EQS %% Hnull: t=tnull (symmetric)
        adjpval=( 1 + length(find(pbeqs<=significance{3}{3}.plevel))) / (B1+1) ;
        if adjpval<=alpha; adjTest=1; else adjTest=0; end
        significance{6}{3}=struct('name', 'Adj Per |t-tnull|=0', 'reject', adjTest, 'plevel', adjpval);
    end
    if EQA  %% Hnull: t=tnull, non-symmetric by inversion of confidence interval
        adjpval=( 1 + length(find(pbeqa<=significance{3}{4}.plevel))) / (B1+1) ;
        if adjpval<=alpha; adjTest=1; else adjTest=0; end
        significance{6}{4}=struct('name', 'Adj Per t-tnull=0', 'reject', adjTest, 'plevel', adjpval);
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%
% ci_method 4: Studentised Significance
%%%%%%%%%%%%%%%%%%%%%%%%%%
if STU    
    Z=(T-t)./stdT;
    if LEQ %% Hnull: t=t0 against t>tnull
        s=(t-tnull)/stdt;  % Test statistic: S=T-tnull; large values are evidence against Hnull
        S=sort(Z);  % Test statistic Null distribution: S*=T*-t
        if s>=S(sIDupalpha); stuTest=1; else stuTest=0; end   % Test
        stupval=(1+length(find(S>=s)))/(B1+1);  % pvalue
        significance{4}{1}=struct('name', 'Student Alt: t>tnull', 'reject', stuTest, 'plevel', stupval);
    end
    if GEQ %% Hnull: t=t0 against t<tnull
        s=-(t-tnull)/stdt;  % Test statistic: S=T-tnull; large values are evidence against Hnull
        S=-sort(Z);  % Test statistic Null distribution: S*=T*-t
        if s>=S(sIDloalpha); stuTest=1; else stuTest=0; end   % Test
        stupval=(1+length(find(S>=s)))/(B1+1);  % pvalue
        significance{4}{2}=struct('name', 'Student Alt: t<tnull', 'reject', stuTest, 'plevel', stupval);
    end
    if EQS %% Hnull: t=tnull (symmetric)        
        s=abs(t-tnull)/stdt;     % Test statistic: S=|T-tnull|; large values are evidence against Hnull
        S=sort(abs(Z)); % Test statistic Null distribution: S*=|T*-t|        
        if s>=S(sIDupalpha); stuTest=1; else stuTest=0; end   % Test         
        stupval=(1+length(find(S>=s)))/(B1+1);  % pvalue
        significance{4}{3}=struct('name', 'Student |t-tnull|=0', 'reject', stuTest, 'plevel', stupval);
    end
    if EQA %% Hnull: t=tnull, non-symmetric
        s=(t-tnull)/stdt;  % Test statistic: S=T-tnull; large values are evidence against Hnull
        S=sort(Z); % Test statistic Null distribution: S*=T*-t       
        if (s>=S(IDupalpha))|(s<=S(IDloalpha)); stuTest=1; else stuTest=0; end   % Test 
        p1=(1+length(find(S>=s)))/(B1+1);
        p2=(1+length(find(S<=s)))/(B1+1);
        stupval=2*min(p1,p2);  % p-value
        significance{4}{4}=struct('name', 'Student t-tnull=0', 'reject', stuTest, 'plevel', stupval);
    end
end

end % CLOSING MAIN FUNCTION DEFINITION

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% V - INLINE FUNCTION DEFINITIONS
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [alphaN]=absNstd(z);
% cdf of |X|, X~N(0,1)
alphaN= erf(z/sqrt(2));
alphaN(find(alphaN<0))=0;
end % closing function definition

function [zN]=invabsNstd(alphaN);
% Inverse cdf of |X|, X~N(0,1)
alphaN(find(alphaN<0))=NaN;
alphaN(find(alphaN>1))=NaN;
zN = sqrt(2)*erfinv(alphaN);
end % closing function definition
